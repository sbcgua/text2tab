"use strict";(self.webpackChunkdocsite=self.webpackChunkdocsite||[]).push([[454],{6341:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>s,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"parsing-options","title":"Parsing options and features","description":"Field name remapping","source":"@site/docs/03-parsing-options.md","sourceDirName":".","slug":"/parsing-options","permalink":"/text2tab/docs/parsing-options","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Installation","permalink":"/text2tab/docs/installation"},"next":{"title":"Deep parsing","permalink":"/text2tab/docs/deep-parsing"}}');var a=t(4848),i=t(8453);const s={sidebar_position:3},o="Parsing options and features",l={},c=[{value:"Field name remapping",id:"field-name-remapping",level:2},{value:"Ignore non-flat fields",id:"ignore-non-flat-fields",level:2},{value:"Type-less parsing",id:"type-less-parsing",level:2},{value:"Corresponding parsing",id:"corresponding-parsing",level:2},{value:"Data formats",id:"data-formats",level:2},{value:"Comments",id:"comments",level:2}];function d(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"parsing-options-and-features",children:"Parsing options and features"})}),"\n",(0,a.jsx)(n.h2,{id:"field-name-remapping",children:"Field name remapping"}),"\n",(0,a.jsx)(n.p,{children:"Change target field name on-the-fly. (Useful e.g. for data migration)"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-abap",children:"* Input text to parse:\r\n* FULL_NAME  BIRTHDATE\r\n* ALEX       01.01.1990\r\n* JOHN       02.02.1995\r\n\r\n  data lt_map type zcl_text2tab_parser=>tt_field_name_map.\r\n  field-symbols <map> like line of lt_map.\r\n  append initial line to lt_map assigning <map>.\r\n  <map>-from = 'Full_name'.\r\n  <map>-to   = 'name'.\r\n\r\n...\r\n\r\nzcl_text2tab_parser=>create( lt_container )->parse(\r\n  exporting\r\n    i_rename_fields = lt_map \" <<<<<<< FIELD MAP\r\n    i_data          = my_get_some_raw_text_data( )\r\n  importing\r\n    e_container = lt_container ).\r\n\r\n* Output data:\r\n* NAME  BIRTHDATE\r\n* ALEX  01.01.1990\r\n* JOHN  02.02.1995\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Renames can be also passed as a string in this format: ",(0,a.jsx)(n.code,{children:"'field_to_rename:new_name;another_field:another_new_name'"}),". Coding convenience is important ;)"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-abap",children:"zcl_text2tab_parser=>create( lt_container )->parse(\r\n  exporting\r\n    i_rename_fields = 'Full_name:name'\r\n    i_data          = my_get_some_raw_text_data( )\r\n  importing\r\n    e_container = lt_container ).\r\n\n"})}),"\n",(0,a.jsx)(n.h2,{id:"ignore-non-flat-fields",children:"Ignore non-flat fields"}),"\n",(0,a.jsxs)(n.p,{children:["Sometimes your structure contain technical non-flat fields which are not supposed to be in source data but present in the target structure. In example, color settings for ALV. It would be cumbersome to create a separate structure just for data. You can specify ",(0,a.jsx)(n.code,{children:"i_ignore_nonflat = abap_true"})," during parser creation so that non-flat components are ignored. The parser will not throw ",(0,a.jsx)(n.code,{children:"Structure must be flat"})," error. However, it will still check that ignored fields are not in the source data."]}),"\n",(0,a.jsxs)(n.p,{children:["E.g. target structure is ",(0,a.jsx)(n.code,{children:"'DATE,CHAR,COLORCOL'"}),", where ",(0,a.jsx)(n.code,{children:"colorcol"})," is a structure. The parser will accept and parse data like"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"DATE        CHAR\r\n01.01.2019  ABC\n"})}),"\n",(0,a.jsx)(n.p,{children:"But will fail on"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"DATE        CHAR       COLORCOL\r\n01.01.2019  ABC        123\n"})}),"\n",(0,a.jsx)(n.h2,{id:"type-less-parsing",children:"Type-less parsing"}),"\n",(0,a.jsx)(n.p,{children:"You can also create an instance that does not validate type against some existing type structure. Instead it generates the table dynamically, where each field if the line is unconverted string."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-abap",children:'data:\r\n  lr_data   type ref to data,\r\n  lt_fields type string_table.\r\n\r\nzcl_text2tab_parser=>create_typeless( )->parse( \r\n  exporting \r\n    i_data      = my_get_some_raw_text_data( )\r\n  importing \r\n    e_head_fields = lt_fields  " Contain the list of field names !\r\n    e_container   = lr_data ). " The container is created inside the parser\n'})}),"\n",(0,a.jsx)(n.h2,{id:"corresponding-parsing",children:"Corresponding parsing"}),"\n",(0,a.jsx)(n.p,{children:"It does actually what it states - move only those field which are the same, example is below."}),"\n",(0,a.jsx)(n.p,{children:"Source text file"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"NAME     BIRTHDATE\r\nALEX     01.01.1990\r\nJOHN     02.02.1995\r\nLARA     03.03.2000\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-abap",children:'types:\r\n  begin of my_table_type,\r\n    name      type char10, " The only corresponding name\r\n    _other    type string, " "Birth date" is not here but "_other" is\r\n  end of my_table_type.\r\n\r\ndata lt_container type my_table_type.\r\n\r\nzcl_text2tab_parser=>create( lt_container )->parse(\r\n  exporting\r\n    i_data          = my_get_some_raw_text_data( )\r\n    i_strict        = abap_false " corresponding is in fact non-strict, so must be false\r\n    i_corresponding = abap_true\r\n  importing\r\n    e_container = lt_container ).\n'})}),"\n",(0,a.jsx)(n.h2,{id:"data-formats",children:"Data formats"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"create"})," accepts parameters that control expected data formatting:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.em,{children:"i_amount_format"})," - a ",(0,a.jsx)(n.code,{children:"char2"})," value, 1st char specifies thousand delimiter, 2nd - fractional delimiter. E.g. ",(0,a.jsx)(n.code,{children:"' ,'"})," - for ",(0,a.jsx)(n.code,{children:"1 234,56"})," and also ",(0,a.jsx)(n.code,{children:"1234,56"}),", ",(0,a.jsx)(n.code,{children:"',.'"})," would expect ",(0,a.jsx)(n.code,{children:"1,234.56"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.em,{children:"i_date_format"})," - a ",(0,a.jsx)(n.code,{children:"char4"})," value, where first 3 defines the order of day, month and year, and the last is the separator between them. E.g. ",(0,a.jsx)(n.code,{children:"YMD"})," for ",(0,a.jsx)(n.code,{children:"20180901"}),", ",(0,a.jsx)(n.code,{children:"DMY-"})," for ",(0,a.jsx)(n.code,{children:"01-09-2018"}),". Supported separators are ",(0,a.jsx)(n.code,{children:"./-"})," and empty char."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"comments",children:"Comments"}),"\n",(0,a.jsxs)(n.p,{children:["Since version 2.2.0 the text file can contain comment lines. A comment lines begins with one specific char, which is supplied in the factory method ",(0,a.jsx)(n.code,{children:"create"}),".\r\nA sample text-file:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"* comment line: expected birthdays in test class ...\r\nNAME    BIRTHDAY\r\nJOHN    01.01.1990\n"})}),"\n",(0,a.jsx)(n.p,{children:"Now we should call the factory method like this and the first line is interpreted as a comment:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-abap",children:"zcl_text2tab_parser=>create( i_pattern = ls_birthday i_begin_comment = '*' ).\n"})}),"\n",(0,a.jsx)(n.p,{children:"The char '*' must have the first position in the text line.  Otherwise it isn't interpreted as a comment."}),"\n",(0,a.jsxs)(n.p,{children:["The comment (or rather the description) line can also be auto-detected with ",(0,a.jsx)(n.code,{children:"i_begin_comment = zif_text2tab=>c_auto_detect_by_space"}),". It tries to find spaces in the first line of the text and, if found, ignores this first line. The idea is that the descriptions will probably have spaces, while abap field names will not:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"Name    Date of birth <<< containes spaces\r\nNAME    BIRTHDAY\r\nJOHN    01.01.1990\n"})})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var r=t(6540);const a={},i=r.createContext(a);function s(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);