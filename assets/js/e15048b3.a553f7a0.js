"use strict";(self.webpackChunkdocsite=self.webpackChunkdocsite||[]).push([[371],{2077:(e,t,a)=>{a.d(t,{A:()=>i});const i=a.p+"assets/images/tab-delimited-text-serializer-debug-5eb9ef441d80734087564154f7fba034.png"},4206:e=>{e.exports=JSON.parse('{"permalink":"/text2tab/blog/tab-delimited-text-serializer","source":"@site/blog/2018-09-02-tab-delimited-text-serializer/index.md","title":"Abap tab-delimited text serializer","description":"My first article on this topic was quite a while ago - Abap tab-delimited text parser - Since then I added some improvements to the project.","date":"2018-09-02T00:00:00.000Z","tags":[{"inline":false,"label":"old","permalink":"/text2tab/blog/tags/old","description":"Old posts (SAP Community)"}],"readingTime":2.33,"hasTruncateMarker":true,"authors":[{"name":"Alexander Tsybulsky","title":"SAP Consultant, developer, sbcg.com.ua CEO","url":"https://github.com/sbcgua","socials":{"linkedin":"https://www.linkedin.com/in/atsybulsky/","github":"https://github.com/sbcgua"},"imageURL":"https://github.com/sbcgua.png","key":"sbcgua","page":null}],"frontMatter":{"slug":"tab-delimited-text-serializer","title":"Abap tab-delimited text serializer","authors":"sbcgua","tags":["old"]},"unlisted":false,"nextItem":{"title":"Abap tab-delimited text parser","permalink":"/text2tab/blog/tab-delimited-text-parser"}}')},8453:(e,t,a)=>{a.d(t,{R:()=>n,x:()=>l});var i=a(6540);const s={},r=i.createContext(s);function n(e){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:n(e.components),i.createElement(r.Provider,{value:t},e.children)}},8664:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>n,metadata:()=>i,toc:()=>d});var i=a(4206),s=a(4848),r=a(8453);const n={slug:"tab-delimited-text-serializer",title:"Abap tab-delimited text serializer",authors:"sbcgua",tags:["old"]},l=void 0,o={authorsImageUrls:[void 0]},d=[{value:"Serializer - new feature",id:"serializer---new-feature",level:2},{value:"The parser improvements",id:"the-parser-improvements",level:2},{value:"Type-less parsing",id:"type-less-parsing",level:3},{value:"Technical changes",id:"technical-changes",level:2}];function c(e){const t={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:["My first article on this topic was quite a while ago - ",(0,s.jsx)(t.a,{href:"/blog/tab-delimited-text-parser",children:"Abap tab-delimited text parser"})," - Since then I added some improvements to the project."]}),"\n",(0,s.jsx)(t.h2,{id:"serializer---new-feature",children:"Serializer - new feature"}),"\n",(0,s.jsxs)(t.p,{children:["The main new feature is serializing. ",(0,s.jsx)(t.code,{children:"ZCL_TEXT2TAB_SERIALIZER"})," class supports serialization of flat tables and structures. Here is how it works:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-abap",children:"data lo_serializer type ref to zcl_text2tab_serializer.\r\n\r\nlo_serializer = zcl_text2tab_serializer=>create(\r\n  \" the below params are all optional and have defaults inside\r\n  i_decimal_sep = ','\r\n  i_date_format = 'DMY.'\r\n  i_max_frac_digits = 5 \" For floats only ! not for decimals\r\n  i_use_lf = abap_true \" to use LF as line-break (not CRLF)\r\n).\r\n\r\ndata lv_string type string.\r\nlv_string = lo_serializer->serialize( lt_some_table ).\n"})}),"\n",(0,s.jsx)(t.p,{children:"The produced result would be something like:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-text",children:"NAME BIRTHDATE\r\nALEX 01.01.1990\r\nJOHN 02.02.1995\r\nLARA 03.03.2000\n"})}),"\n",(0,s.jsx)(t.p,{children:"As can be seen from the code you can parametrize the date and amount formatting. E.g. for dates you can define the order of day, month and year and the separator symbol (the 4th char of the parameter)"}),"\n",(0,s.jsx)(t.h2,{id:"the-parser-improvements",children:"The parser improvements"}),"\n",(0,s.jsx)(t.p,{children:"The parser itself got some improvements"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Support for LF line breaks. Before just CRLF was supported, and now it is auto-detected"}),"\n",(0,s.jsx)(t.li,{children:"Support for double quotes around the field value (removed during the parsing)"}),"\n",(0,s.jsxs)(t.li,{children:["Support for specifying the date format - same logic like in serializer (e.g. ",(0,s.jsx)(t.code,{children:"DMY."})," would expect dates like ",(0,s.jsx)(t.code,{children:"01.09.2018"}),")"]}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"type-less-parsing",children:"Type-less parsing"}),"\n",(0,s.jsx)(t.p,{children:"The most noticeable change is type-less parsing. The parsed data is not validated against any specific structure. Instead it just reads the header line and dynamically creates the line structure out of it where each field is string and parsed without additional conversion. For example:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-abap",children:'data:\r\n  lr_data   type ref to data,\r\n  lt_fields type string_table.\r\n\r\nzcl_text2tab_parser=>create_typeless( )->parse( \r\n  exporting \r\n    i_data      = my_get_some_raw_text_data( )\r\n  importing \r\n    e_head_fields = lt_fields  " Contain the list of field names\r\n    e_container   = lr_data ). " The container is created inside the parser\n'})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Debugger view",src:a(2077).A+"",width:"855",height:"103"})}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"e_container"})," will receive the data ref to the parsed table. For the data example in paragraph 1 the line type would contain respectively 2 fields: ",(0,s.jsx)(t.code,{children:"NAME"})," and ",(0,s.jsx)(t.code,{children:"BIRTHDATE"})," of string type each. The table can be e.g. passed to SALV."]}),"\n",(0,s.jsx)(t.h2,{id:"technical-changes",children:"Technical changes"}),"\n",(0,s.jsxs)(t.p,{children:["In the previous version the code lived in local classes in includes. Now the classes are global and also changed their names. The product is now called ",(0,s.jsx)(t.strong,{children:"TEXT2TAB"})," and not ",(0,s.jsx)(t.em,{children:"DATA_PARSER"}),". Well, that's because is not some abstract 'data' actually but tab-delimited text processor ... and also it is not only the 'parser' anymore ..."]}),"\n",(0,s.jsxs)(t.p,{children:["The code is open sourced and can be found in this ",(0,s.jsx)(t.a,{href:"https://github.com/sbcgua/text2tab",children:"github repository"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["The best way to install the tool would be ",(0,s.jsx)(t.a,{href:"https://github.com/abapGit/abapGit",children:"abapGit"})," - this is an amazing developer tool, if you haven't tried it yet, you really should."]}),"\n",(0,s.jsxs)(t.p,{children:["P.S. ",(0,s.jsxs)(t.em,{children:["Originally posted at ",(0,s.jsx)(t.a,{href:"https://community.sap.com/t5/application-development-and-automation-blog-posts/text2tab-tab-delimited-text-parser-and-now-also-serializer/ba-p/13365819",children:"SAP Community platform"})," on 2016-Aug-28"]})]})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}}}]);