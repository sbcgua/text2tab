"use strict";(self.webpackChunkdocsite=self.webpackChunkdocsite||[]).push([[775],{8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>a});var r=n(6540);const i={},o=r.createContext(i);function s(e){const t=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(o.Provider,{value:t},e.children)}},9101:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>a,default:()=>p,frontMatter:()=>s,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"deep-parsing","title":"Deep parsing","description":"If you have a target data with deep fields - tables or structures - it is possible to fill them in one run. For this you have to create a data source provider implementing ziftext2tabdeepprovider and pass it to the parser. An example of implementation can be found in mockuploader. But let\'s consider an simple example here.","source":"@site/docs/04-deep-parsing.md","sourceDirName":".","slug":"/deep-parsing","permalink":"/text2tab/docs/deep-parsing","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Parsing options and features","permalink":"/text2tab/docs/parsing-options"},"next":{"title":"Error handling","permalink":"/text2tab/docs/error-handling"}}');var i=n(4848),o=n(8453);const s={sidebar_position:3},a="Deep parsing",d={},l=[];function c(e){const t={a:"a",code:"code",em:"em",h1:"h1",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"deep-parsing",children:"Deep parsing"})}),"\n",(0,i.jsxs)(t.p,{children:["If you have a target data with deep fields - tables or structures - it is possible to fill them in one run. For this you have to create a data source provider implementing ",(0,i.jsx)(t.code,{children:"zif_text2tab_deep_provider"})," and pass it to the parser. An example of implementation can be found in ",(0,i.jsx)(t.a,{href:"https://github.com/sbcgua/mockup_loader",children:"mockup_loader"}),". But let's consider an simple example here."]}),"\n",(0,i.jsx)(t.p,{children:"Let's assume you have 2 linked tables - header and lines"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-text",children:"DOCUMENT\r\n========\r\nID   DATE   ...\r\n1    ...\r\n2    ...\r\n\r\nLINES\r\n========\r\nDOCID   LINEID   AMOUNT   ...\r\n1       1        100.00   ...\r\n1       2        123.00   ...\r\n2       1        990.00   ...\n"})}),"\n",(0,i.jsx)(t.p,{children:"Let's assume you have a target data of the following structure"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-abap",children:'types:\r\n  begin of ty_line,\r\n    docid  type numc10,\r\n    lineid type numc3,\r\n    " ...\r\n  end of ty_line,\r\n  tt_line type table of ty_line,\r\n  begin of ty_document,\r\n    id   type numc10,\r\n    " ...\r\n    lines type tt_line, " <<< DEEP FIELD, supposed to be filled with lines of the document\r\n  end of ty_document,\r\n  tt_documents type table of ty_document.\r\n\n'})}),"\n",(0,i.jsx)(t.p,{children:"So you can run the parser as follows to parse all at once"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-abap",children:"zcl_text2tab_parser=>create( \r\n  i_pattern = lt_container \r\n  i_deep_provider = lo_implementation_of_zif_text2tab_deep_provider\r\n)->parse(\r\n  exporting\r\n    i_data          = my_raw_text_data\r\n  importing\r\n    e_container = lt_container ).\n"})}),"\n",(0,i.jsxs)(t.p,{children:["So what is ",(0,i.jsx)(t.code,{children:"lo_implementation_of_zif_text2tab_deep_provider"})," in this example? The parser does not know how to get additional data other than ",(0,i.jsx)(t.code,{children:"my_raw_text_data"}),". The implementation of ",(0,i.jsx)(t.code,{children:"zif_text2tab_deep_provider"})," should. Maybe you want to get it from a file, which is located somewhere near, or download from web, or just select from a DB table - this is up to your design and need. For example, the mentioned ",(0,i.jsx)(t.a,{href:"https://github.com/sbcgua/mockup_loader",children:"mockup_loader"}),' uses the text value in place of "deep" field in order to find the data and parse it. The source file should contain a reference in place of "deep" field to help finding the source data. E.g.']}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-text",children:"DOCUMENT\r\n========\r\nID   DATE   ...   LINES\r\n1    ...          lines.txt[docid=@id]\r\n2    ...          lines.txt[docid=@id]\n"})}),"\n",(0,i.jsxs)(t.p,{children:["where mockup_loader interprets ",(0,i.jsx)(t.code,{children:"lines.txt[docid=@id]"})," as ",(0,i.jsxs)(t.em,{children:['"go find lines.txt file, parse it, extract the lines, filter those where ',(0,i.jsx)(t.code,{children:"docid"})," = ",(0,i.jsx)(t.code,{children:"id"}),' value of the current header record"']}),"."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"zif_text2tab_deep_provider"})," requires just one method to implement - ",(0,i.jsx)(t.code,{children:"select"}),"."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-abap",children:'methods select\r\n  importing\r\n    i_address type string " e.g. filename[key_field_name=123]\r\n    i_cursor  type any    " reference to currently processed data line to fetch field values\r\n  exporting\r\n    e_container type any.\n'})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"i_address"}),' is the value of "deep" field in text data (in our example value of ',(0,i.jsx)(t.code,{children:"LINES"})," field - ",(0,i.jsx)(t.code,{children:"lines.txt[docid=@id]"}),")"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"i_cursor"})," is the current record with parsed field values (in our example: id, date, ...)"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"e_container"})," is the target component of the current record (in our example - ",(0,i.jsx)(t.code,{children:"LINES"})," component of ",(0,i.jsx)(t.code,{children:"ty_document"}),")"]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:['So the implementation of the interface must parse the address and get the "deep" data. You are not limited to the specific address format, however, if you want to follow the format described above (',(0,i.jsx)(t.code,{children:"<sourceref>[<sourcekeyfield>=<cursorkeyfield>]"}),"), you can reuse ",(0,i.jsx)(t.code,{children:"parse_deep_address"})," and ",(0,i.jsx)(t.code,{children:"get_struc_field_value_by_name"})," methods implemented in ",(0,i.jsx)(t.code,{children:"zcl_text2tab_utils"}),"."]})]})}function p(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);